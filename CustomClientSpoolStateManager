package com.tcs.flume.mme.client;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

public class CustomClientSpoolStateManager
{
	
	Logger logger = Logger.getLogger(CustomFlumeClient.class);
	
	public enum FileProcessingState {
		PENDING, IN_PROCESS, FAILED, SUCCEDED
	}

	protected HashMap< String, FileProcessingState > stateMap;
	protected String filePath;

	public CustomClientSpoolStateManager( String filePath ) 
	{
		
		PropertyConfigurator.configure("log4j.properties");
		this.filePath = filePath + "/ssh-spool-state.out";
		this.stateMap = new HashMap< String, FileProcessingState >();

		loadMap();
		markUnprocessedAsError();
	}

	public ArrayList< String > getPending() 
	{
		PropertyConfigurator.configure("log4j.properties");

		ArrayList< String > pending = new ArrayList< String >();
		for( Map.Entry< String, FileProcessingState > entry: stateMap.entrySet() )
		{
			//String filename=entry.getKey().toString();
			

			if( entry.getValue() == FileProcessingState.PENDING )
			{
				pending.add( entry.getKey() );
			}
		}
		return pending;
	}
	
	public void removeList(String fileName)
	{
       FileProcessingState hasHValue=stateMap.get(fileName);
		
		if(hasHValue.equals(FileProcessingState.SUCCEDED))
		{
			
			boolean success = (new File(fileName)).delete();
			if (success)
			{
				logger.info("Removing Successfully loaded file "+ fileName +" from disk");   
			}
			else
			{
				logger.info("File not deleted");
				
			}
			stateMap.remove(fileName);

			logger.info("Removing Hash Entry of successfully loaded file");

		}
		
	}

	public void addProcessingList( ArrayList< String > paths ) 
	{
		PropertyConfigurator.configure("log4j.properties");
		for( String file: paths ) 
		{
			if( !stateMap.containsKey( file ) ) 
			{
				stateMap.put( file, FileProcessingState.PENDING );
			}
		}


		saveState();
	}

	public void markFinished( String file ) 
	{
		stateMap.put( file, FileProcessingState.SUCCEDED );
		saveState();
	}

	public void markError( String file ) 
	{
		stateMap.put( file, FileProcessingState.FAILED );
		saveState();
	}

	public void markInProcess( String file ) 
	{
		stateMap.put( file, FileProcessingState.IN_PROCESS );
		saveState();
	}

	public void markUnprocessedAsError() 
	{
		PropertyConfigurator.configure("log4j.properties");
		for( Map.Entry< String, FileProcessingState > entry: stateMap.entrySet() )
		{
			if( entry.getValue() == FileProcessingState.IN_PROCESS )
			{
				logger.info( entry.getKey() + " is marked as in_process, updating to error " );
				entry.setValue( FileProcessingState.FAILED );
			}
		}
		saveState();
	}

	public void saveState() 
	{
		PropertyConfigurator.configure("log4j.properties");

		try {
			saveMap();
		} catch( IOException e ) {
			logger.error( e.toString() );
			logger.error( "SshSpoolStateManager: Unable to persist state to disk. Crashing..." );
			System.exit(-1);
		}
	}

	protected void saveMap() throws IOException {
		ObjectOutputStream oos = new ObjectOutputStream (new FileOutputStream( filePath ));
		oos.writeObject(stateMap);
		oos.close();
	}

	protected void loadMap() 
	{
		PropertyConfigurator.configure("log4j.properties");

		try{ 
			ObjectInputStream ois = new ObjectInputStream( new FileInputStream( new File(filePath) ));
			Object readMap = ois.readObject();
			if(readMap != null && readMap instanceof HashMap) {
				stateMap.putAll((HashMap) readMap);
			}
			ois.close();
		} catch ( FileNotFoundException e ) {
			logger.error("Error is "+e);
		} catch ( IOException e ) {
			logger.error("Error is "+e.getStackTrace());
		} catch ( ClassNotFoundException e ) {
			logger.error("Error is "+e);
		}
	}

}
